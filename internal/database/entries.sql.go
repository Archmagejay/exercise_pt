// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: entries.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const addEntry = `-- name: AddEntry :one
INSERT INTO entries (
    id,
    user_id,
    date,
    cardio,
    cardio_type,
    plate_count,
    plank_dur,
    weight,
    waist,
    park_run
) VALUES (
    $1,$2,$3,$4,$5,$6,$7,$8,$9,$10
)
RETURNING id, user_id, date, cardio, cardio_type, plate_count, plank_dur, weight, waist, park_run
`

type AddEntryParams struct {
	ID         uuid.UUID      `json:"id"`
	UserID     uuid.UUID      `json:"user_id"`
	Date       time.Time      `json:"date"`
	Cardio     string         `json:"cardio"`
	CardioType bool           `json:"cardio_type"`
	PlateCount []int32        `json:"plate_count"`
	PlankDur   sql.NullString `json:"plank_dur"`
	Weight     string         `json:"weight"`
	Waist      string         `json:"waist"`
	ParkRun    sql.NullString `json:"park_run"`
}

// Add a new entry to 'entries
func (q *Queries) AddEntry(ctx context.Context, arg AddEntryParams) (Entry, error) {
	row := q.db.QueryRowContext(ctx, addEntry,
		arg.ID,
		arg.UserID,
		arg.Date,
		arg.Cardio,
		arg.CardioType,
		pq.Array(arg.PlateCount),
		arg.PlankDur,
		arg.Weight,
		arg.Waist,
		arg.ParkRun,
	)
	var i Entry
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Date,
		&i.Cardio,
		&i.CardioType,
		pq.Array(&i.PlateCount),
		&i.PlankDur,
		&i.Weight,
		&i.Waist,
		&i.ParkRun,
	)
	return i, err
}

const getLatestEntryTimestampForUser = `-- name: GetLatestEntryTimestampForUser :one
SELECT date FROM entries
WHERE user_id = $1
ORDER BY date DESC
LIMIT 1
`

// Get the timestamp for the latest entry by the specified user from 'entries
func (q *Queries) GetLatestEntryTimestampForUser(ctx context.Context, userID uuid.UUID) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, getLatestEntryTimestampForUser, userID)
	var date time.Time
	err := row.Scan(&date)
	return date, err
}

const getLatestPlateCountForUser = `-- name: GetLatestPlateCountForUser :one
SELECT plate_count
FROM entries
WHERE user_id = $1
ORDER BY date DESC
LIMIT 1
`

// Get the latest plate count for a specified user (Bench Press, L)
func (q *Queries) GetLatestPlateCountForUser(ctx context.Context, userID uuid.UUID) ([]int32, error) {
	row := q.db.QueryRowContext(ctx, getLatestPlateCountForUser, userID)
	var plate_count []int32
	err := row.Scan(pq.Array(&plate_count))
	return plate_count, err
}

const getLatestWeeklyDataTimestampForUser = `-- name: GetLatestWeeklyDataTimestampForUser :one
SELECT date
FROM entries
WHERE user_id = $1
AND weight IS NOT NULL
AND waist IS NOT NULL
LIMIT 1
`

// Get the timestamp for the latest entry that has a non null weekly value (weight, waist)
func (q *Queries) GetLatestWeeklyDataTimestampForUser(ctx context.Context, userID uuid.UUID) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, getLatestWeeklyDataTimestampForUser, userID)
	var date time.Time
	err := row.Scan(&date)
	return date, err
}

const resetTable = `-- name: ResetTable :exec
DELETE FROM entries
`

// Delete all rows from 'entries'
func (q *Queries) ResetTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, resetTable)
	return err
}
